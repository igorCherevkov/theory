----Типы данных

ecma script - спецификация написания кода на языке js, которая нужна для стандартизации языка.
самое большое обновление - es6 были добавлены классы, модули, стрелочные функции, промисы, спред и тп
8 типов данных:
7 примитивных и 1 ссылочный
примитивные:
number, bigint, string, symbol, boolean, null, undefined
ссылочный - объекты

-----Что такое переменная, оператор, выражение, функция? Что такое унарный, бинарный, тернарный операторы? Назовите операторы каждого типа.

переменная - хранилище данных, она используется для хранения каких либо значений
оператор - символ, использующийся для выполнения операция над значениями и переменными, например 10+5
выражение - комбинация переменных, значений и операторов, которая вычисляет некоторое значение, 10+5-2
функция - переиспользуемый блок кода, который выполняет какую либо задачу и возвращает результат

унарный оператор - оператор, который работает с одним операндом (значением или переменной)
++ - инкремент
-- - декремент
! - логическое отрицание
typeof - определение типа
- - унарный минус, делает число отрицательным
+ - унарный плюс, преобразует неявно строку к числу

бинарный оператор, он работает с двумя операндами
Арифметические: +, -, *, /, %, **
Сравнительные: ==, ===, !=, !==, >, <, >=, <=
Логические: &&, ||, ||=, &&=, ??, ??=
Побитовые: &, |, ^, <<, >>, >>>
Присваивания: =, +=, -=, *=, /=, %=

!! - двойное не, переводит в булевый тип, те сначала переменная переводится в булевый тип,
затем выполняется !, а затем ! переводит переменную уже в исходный булевый тип
Boolean() используется как !!

Например, здесь мы отобразим user, если её значение не null/undefined, в противном случае Аноним
?? возвращает первое не null/undefined
let user;
alert(user ?? "Аноним"); // Аноним (user не существует)

По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.
Выполнение следующего кода приведёт к синтаксической ошибке

Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).

тернарный оператор работает с тремя операндами, это укороченная запись условия if else
return (условие) ? 10 : 20 - возвратит 10, если условие верное, иначе 20

-------Операторы равно

оператор = - оператор присваивания, он задаёт значение какой либо переменной
оператор == - не строгое равенство, это значит, что переменные приводятся к одному типу, после чего сравниваются, 
изначально переменные приводятся к типу number, если одна из них смогла привестись, а другая нет, то false выдаёт
оператор === - строгое равенство, это значит, что если типы переменных разные, то это сразу false

------Условные конструкции

if (условие) {
} else if (условие) {
} else {
}

если условие в скобках if верное, то выполнится этот блок кода, если условие верное в else if, выполнится 
этот блок кода, если if и else if неверные, выполнится else

switch используется для проверки одного выражение на соответсвие нескольким значениям

let fruit = 'apple';

switch (fruit) {
	case "apple":
		console.log("apple")
		break;
	case 'banana':
		console.log("banana")
		break;
	default:
		console.log("неизвестный фрукт")
}

блок default выполняется, если ни одно из условий не было выполнено

-------Циклы

for - используется, когда известно, сколько раз нужно выполнить определённое действие.
Цикл while выполняется, пока условие истинно.
Цикл do-while выполняется по крайней мере один раз, даже если условие ложно, потому что проверка условия происходит в конце цикла.
Цикл for...in перебирает свойства объекта.
Цикл for...of перебирает элементы итерируемых объектов (массивы, строки и т. д.).

оператор continue используется для пропуска данной итерации, например в цикле мы можем задать при i=3 continue, 
и потом console.log(i), то есть цифру 3 не выведет

оператор break используется для прекращения всего цикла, например в цикле мы можем задать при i=3 break,
и на этом цикл завершится

outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
} -- прерывание внешнего цикла

if (i > 5) {
  alert(i);
} else {
  continue;
}
 -- синтаксическая ошибка

---------фукнции

function expression - function <name>() {}
function declaration - let func = function() {}

Функция, созданная через объявление функции, является объектом Function и обладает всеми свойствами, методами и поведением объектов такого типа
По умолчанию функции возвращают undefined. Чтобы вернуть другое значение, функция должна содержать инструкцию return, которая указывает, какое значение возвращать.
Объявление функции в JavaScript поднимает определение функции. Вы можете использовать функцию до того, как вы её объявили
Функциональные выражения в JavaScript не поднимаются (hoisting), в отличие от объявленных функций. Вы не можете использовать функциональные выражения прежде, чем вы их определили.
Если вы хотите сослаться на текущую функцию внутри тела этой функции, вам необходимо создать именованное функциональное выражение. Данное имя будет локальным только для тела функции (её области видимости). Кроме того, это позволяет избежать использования нестандартного свойства arguments.callee.
var math = {
  factit: function factorial(n) {
    console.log(n);
    if (n <= 1) {
      return 1;
    }
    return n * factorial(n - 1);
  },
};

math.factit(3); //3;2;1;

Имя именованного функционального выражения доступно только внутри самой функции.
let factorial = function fact(n) {
  if (n <= 1) {
    return 1;
  }
  return n * fact(n - 1); // Используем имя fact для рекурсивного вызова
};

console.log(factorial(5)); // Вызов функции
// console.log(fact(5)); // Ошибка: fact is not defined, имя fact доступно только внутри функции

чтобы посмотреть имя, мы можем использовать factorial.name

Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.

если мы создали функцию в блоке кода, мы не сможем вызвать ее за пределами блока, для этого
нужно будет нам создать глобальную переменную, и присвоить ей функцию

--------var let const

Переменные, объявленные с помощью var, имеют функциональную область видимости (function scope). Это означает, что переменная доступна внутри функции, в которой она была объявлена, или глобально, если объявлена за пределами функции.
Переменные, объявленные с помощью let и const, имеют блочную область видимости (block scope). Это означает, что переменная доступна только в блоке кода, в котором она была объявлена, или в любом вложенном блоке.
const защищает переменную от переопределения, то есть после инициализация, её нельзя будет изменить. Но если в переменную положен объект или массив, их можно будет изменять, нельзя менять саму переменную

---------преобразования в число

Численное преобразование происходит в математических функциях и выражениях
"6" / "2"
Унарный плюс +'123', +true
Функция Number() явно преобразует значение в число, если не может преобразовать - NaN

Значение	Преобразуется в…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям 
обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

----------математические операции

Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.

Объект Math в JavaScript предоставляет множество математических функций и констант. Он не является функцией-конструктором, поэтому все методы и свойства вызываются статически, т.е. через сам объект Math.
Math.floor
Округление в меньшую сторону

Math.ceil
Округление в большую сторону

Math.round
Округление до ближайшего целого

Math.trunc
Производит удаление дробной части без округления

Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.

Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме

Number.isNaN - проверяет, является ли значение точно NaN
isNaN - преобразует значение к числу и проверяет

Number.isFinite - проверяется, является ли значение числом напрямую
isFinite - преобразует значение в число перед проверкой

Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN. Во всех остальных случаях возвращает false.
Number.isFinite(value) возвращает true только в том случае, если аргумент принадлежит к типу number и не является NaN/Infinity/-Infinity. Во всех остальных случаях возвращает false.

Object.is(a, b) идентичен a === b.
Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру
parseInt('a123') - NaN
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д
parseInt('0xff', 16)

----
Math
random
max/min
pow(n, 2) - число n во второй степени

-------------строки

'', ""
`` - позвляют задать многострочный текст, а так же вписать выражение или переменную ${}

Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos].
Также можно использовать метод str.at(pos)
Как вы можете видеть, преимущество метода .at(pos) заключается в том, что он допускает отрицательную позицию. Если pos – отрицательное число, то отсчет ведется от конца строки.
Таким образом, .at(-1) означает последний символ, а .at(-2) – тот, что перед ним, и т.д.
Квадратные скобки всегда возвращают undefined для отрицательных индексов

Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

Методы toLowerCase() и toUpperCase() меняют регистр символов

Первый метод — str.indexOf(substr, pos).
Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2
Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей

Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой

str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

str.substring(start [, end])
Возвращает часть строки между start и end (не включая) end.

str.substr(start [, length])
Возвращает часть строки от start длины length.

slice и substring похожи, но в slice можно передавать отрицательные значения

str.codePointAt(pos)
String.fromCodePoint(code)
Символы сравниваются по их кодам. Больший код — больший символ

Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
Отрицательное число, если str меньше str2.
Положительное число, если str больше str2.
0, если строки равны.
У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

Используя, например, методы find(), replace().

--------null undefined

Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.
При использовании математических операторов и других операторов сравнения < > <= >=
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)

----------массив

массив - упорядоченная колекция данных, в нем могут храниться элемент любого типа

Существует два варианта синтаксиса для создания пустого массива:
let arr = new Array();
let arr = [];
Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов(undefined), но с заданной длиной.

fruits[fruits.length-1] - fruits.at(-1)

push добавляет элемент в конец.
shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство length. Но в основе всё равно лежит объект.

let fruits = []; // создаём массив
fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива
fruits.length = 100000
Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество элементов массива, а наибольший цифровой индекс плюс один.
fruits.age = 25; // создаём свойство с произвольным именем
Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.
Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов, в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.

Таким образом, самый простой способ очистить массив – это arr.length = 0;.

Операция shift должна выполнить 3 действия:
Удалить элемент с индексом 0.
Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
Обновить свойство length .

Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.
В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят, как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.
Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.
В общем, не следует использовать цикл for..in для массивов.

Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

Итак, если мы всё же сравниваем массивы с помощью ==, то они никогда не будут одинаковыми, если только мы не сравним две переменные, которые ссылаются на один и тот же массив
чтобы сравнить массивы: не используйте оператор ==. Вместо этого сравните их по элементам в цикле или используя методы итерации

arr.splice(start[, deleteCount, elem1, ..., elemN])
Он изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.

arr.slice([start], [end])
Он возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
Синтаксис:
arr.concat(arg1, arg2...)
Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть
Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы

arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
Результат функции (если она что-то возвращает) отбрасывается и игнорируется.

arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.
Метод includes правильно обрабатывает NaN:
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)
alert( arr.includes(NaN) );// true (верно)

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.

У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам элемент. Значение -1 возвращается, если ничего не найдено.
Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf

let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

дочитать про методы массивов глава 5.5

---------------------перебор массива

arr.forEach(callback(item, i, arr)) - возвращает undefined
arr.filter(callback(item, i, arr) { - возвращает новый массив с элементами, удовл. условию
  return item > 0;
})
arr.map(callback(item, i, arr)) - возвращает новый массив, который будет состоять из результатов функции
arr.reduce - вовзращает единое значение

-----
EvalError: представляет ошибку, которая генерируется при выполнении глобальной функции eval()
RangeError: ошибка генерируется, если параметр или переменная, представляют число, которое находится вне некотоого допустимого диапазона
ReferenceError: ошибка генерируется при обращении к несуществующей ссылке
SyntaxError: представляет ошибку синтаксиса
TypeError: ошибка генерируется, если значение переменной или параметра представляют некорректный тип или пр попытке изменить значение, которое нельзя изменять
URIError: ошибка генерируется при передаче функциям encodeURI() и decodeURI() некорректных значений
AggregateError: предоставляет ошибку, которая объединяет несколько возникших ошибок

------
2.18 глава - краткий итог 1

------объекты

Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].

------дата и время
Для создания нового объекта Date нужно вызвать конструктор new Date() с одним из следующих аргументов:
new Date() - Без аргументов – создать объект Date с текущими датой и временем:
new Date(milliseconds) - Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

const now = new Date();
console.log(now);
const year1970 = new Date(0)
console.log(year1970)

const nowMilli = Date.now(); // количество миллисекунд, прошедших с 1970 года
console.log(nowMilli);
console.log(+now)

const date = new Date('2004, 01, 13');
console.log(date);

const nextDate = new Date(2004, 0, 13);
const year = nextDate.getFullYear();
const month = nextDate.getMonth();
const day = nextDate.getDate();
const hours = nextDate.getHours();
const minutes = nextDate.getMinutes();
const seconds = nextDate.getSeconds();
const milliseconds = nextDate.getMilliseconds();
console.log(nextDate, year, month, day, hours, minutes, seconds, milliseconds);
nextDate.setHours(10);
console.log(nextDate);

date.setDate(date.getDate() + 2);
console.log( date );
date.setSeconds(date.getSeconds() + 20);
console.log(date);

const ms = Date.parse(date); // количество милисекунд с этого времени
console.log(ms); 

--------JSON
JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.
Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".
Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30.

JSON.stringify(value[, replacer, space])
JSON поддерживает следующие типы данных:
Объекты { ... }
Массивы [ ... ]
Примитивы:
строки,
числа,
логические значения true/false,
null.

Важное ограничение: не должно быть циклических ссылок.


--------this
Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.

this для рекурсии
Когда функция производит вложенный вызов, происходит следующее:

Выполнение текущей функции приостанавливается.
Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

--------------замыкания
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").
То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.
Когда на собеседовании фронтенд-разработчику задают вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.

Функции counter и counter2 созданы разными вызовами makeCounter.
Так что у них независимые внешние лексические окружения, у каждого из которых свой собственный count.

func()() - чтобы вторые скобки сработали, функция должна вернуть другую функцию

-----
остановился на 6.4